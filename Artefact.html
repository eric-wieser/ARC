<!doctype html>
<html>
	<head>
		<title>The Artefact</title>
		<link rel="stylesheet" type="text/css" href="style.css" />
		<link href='http://fonts.googleapis.com/css?family=Terminal+Dosis+Light|Ubuntu:300|Ubuntu:300italic' rel='stylesheet' type='text/css' />
		<meta http-equiv="x-ua-compatible" content="IE=edge" />
		<!--[if lt IE 9]>
		<script src="//html5shim.googlecode.com/svn/trunk/html5.js"></script>
		<![endif]-->
		<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
		
		<link href="code-prettify/prettify.css" type="text/css" rel="stylesheet" />
		<script type="text/javascript" src="code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
		<h1><span>The Artefact</span></h1>
		<div id="wrapper">
			<section>
				<h2>Wheels</h2>
				<p>The wheels are designed such that they are effectively frictionless in one axis. This is achieved by mounting a set of smaller perpendicular wheels around the circumference. These smaller wheels are free to turn even when the main wheel is held still, allowing a free component of motion along the axis of the wheel. At the same time, the wheel can be powered as normal wheel.</p>
				<aside class="horizontal">
					<figure>
						<img src="images/photos/split-ring.png" alt="Split Ring" />
						<figcaption>The split ring</figcaption>
					</figure>
					<figure>
						<img src="images/photos/hub.png" alt="Hub" />
						<figcaption>The hub</figcaption>
					</figure>
					<figure>
						<img src="images/photos/wheel-assembly.png" alt="Assembly" />
						<figcaption>Assembly</figcaption>
					</figure>
					<figure>
						<img src="images/photos/wheel.png" alt="Wheel" />
						<figcaption>Complete Wheel</figcaption>
					</figure>
					<span></span>
				</aside>
				<p>The small wheels in my design are washers. These are sufficient, as the sharp edge of the washer provides plenty of friction in the direction of drive, and the perpendicular friction is faily low. Additionally, washers are cheap!</p>
				<p>The axles for the washers needs to be a ring. The easiest way to get a ring is from a keychain. The ones the wheels use is a  <a href="http://onestop-key-rings.co.uk/51mm-split-rings-pack-of-10-p-11.html">5.1mm split ring from onestop-key-rings.co.uk</a></p>
				<p>The next thing needed is a way of holding the split ring onto the motor shaft. This was done with a circular laser-cut aluminum hub, held onto the split ring with cable ties.</p>
				<p>The most time consuming part of this aspect of the artefact was designing the aluminum hub. This is partly because of the accuracy required. A technical drawing program was used to design this. The design went through multiple sizes, as the measurements of the washers and split ring were gradually improved. The final design was set off to <a href="http://www.microkerf.com/">microkerf</a>, where it was laser cut in 4mm aluminum</p>
			</section>
			<section id="motors">
				<h2>Motors and Drivers</h2>
				<p>The motors chosen can take up to 3.3A of current. In order to drive these safely, the driver chips have to be able to take at least this much. Initially, the plan was to get at pre built motor drivers, but they were generally too expensive, and either under-speced, or way over-speced. In the end, I decided to cuild the drivers myself</p>
				<p>The chip used was a L298 dual H-bridge, which allows two DC motors to be powered at up to 2A. By paralleling the outputs, a current of 4A can be drawn. This is more than required, but it means there's no chance of the chip blowing up. The other thing the driver requires are clamp diodes to clamp the motor outputs to the supply voltage, preventing reverse EMF, which can damage the driver chip.</p>
				<aside class="horizontal">
					<figure>
						<img src="images/photos/motor.png" alt="Motor" />
						<figcaption><a href="http://www.pololu.com/catalog/product/1162">The motor</a></figcaption>
					</figure>
					<figure>
						<div><img src="images/drawings/motor-board.png" alt="Driver design" />
						<figcaption>The layout of the board</figcaption>
					</figure>
					<figure>
						<img src="images/photos/drivers.png" alt="Assembled drivers" />
						<figcaption>Assembled drivers</figcaption>
					</figure>
					<span></span>
				</aside>
				<p>The original plan was to make a PCB for the entire robot, and assemble the drivers on the PCB. However, PCB fabrication turned out to be expensive, and a lot of work. Instead, the motor drivers were assembled and soldered onto a piece of stripboard, which had the benefit of being prototypable.</p>
				<p>More details on how the motor was chosen can be seen in <a href="Appendices/Motors.html">Appendix A</a></p>
			</section>
			<section>
				<h2>Control system</h2>
				<h3>Direction</h3>
				<p></p>
				<h3>Rotation</h3>
				<p>The formula for the velocity \(v\) of a point of distance \(r\) from the center of rotation, rotating at an angular velocity of \(\omega\) is given by the equation:</p>
				$$v = r\omega$$
				<p>However, this equation is of limited use. Thinking back to the straight-line driving, it is much more convenient if the variables can be expressed as vectors. It can be seen that the velocity of a point displaced \(\mathbf{r}\) from the center of rotation is a tangent to the circular motion, ie \(\mathbf{v}\) is perpendicular to \(\mathbf{r}\).</p>
				<p>From this information, the following equation can be derived:</p>
				$$\mathbf{v} = \mathbf{r}^\perp \times \omega$$
			</section>
			<section>
				<h2>Sensor input</h2>
				<p>The robot has 4 types of sensor. There is a set of 16 infared detectors (the  TSOP 1138), arranged around the circumference, that can detect the ball. There is a set of four Ultrasonic sensors to detect the walls. There is a compass (the HMC6532) to detect the heading of the robot. Finally, there's a laser diode pointed at a photodiode acting as a light gate, to detect the presence of the ball in the ball holder</p>
				<section>
					<h3>Reading the US and IR sensors</h3>
					<p>The ball gives off a 1.2kHz stepped infrared waveform on a 40kHz carrier frequency, which is picked up by the IR detectors on the robot. The signal returned is a PWM signal, with a low pulse every 833&micro;s. The width of this pulse gives the strenth of the signal.</p>
					<p>To use the US (ultrasonic) sensors, the controllerr must send a short high pulse. The sensor will then send an Ultrasonic pings, and respond with a pulse, whose width is the time taken to recieve a bounce. By using the speed of sound, the distance can be obtained</p>
					<p>Initially, both these sensors were read in a tight loop C# side. However, this had big performance impacts, and therefore accuracy problems - the code had to loop through 20 sensors, and catch microsecond-wide pulses. This simply isn't possible with the managed C# code. The solution to this was to use a feature of the FEZ called "RLP", which stands for "Runtime Loadable Procedure". Basically, this allows me to drop down into native C code, which runs far faster than the managed C# code. With this, I wrote a procedure to read all the sensor information simultaneously, then return it to the managed c# code</p>
				</section>
				<section>
					<h3>Combining IR sensor readings</h3>
					<p>To be useful, the readings of all the IR sensors need to be combined to get a single measure of direction. To do this, each sensor was assigned a vector in the sofware, that points in the direction the sensors faces. By taking the strength of each sensor, multiplying it by the direction vector, and summing the vectors to get a resultant. In code:</p>
<pre class="prettyprint">
public Vector Get() {
	Vector sourceDirection = 0;
	foreach (OrientedSensor sensor in Sensors) {
		sourceDirection += sensor.Intensity * sensor.Direction;
	}
	return sourceDirection;
}</pre>
					<p>The result is also scaled, but this is not significant</p>
				</section>
				<section>
					<h3>Using the compass</h3>
					<p>The compass is an I&sup2;C device. An I&sup2;C driver is build into the FEZ, so using the sensor is trivial. I&sup2;C is a data protocol running on two wires. Put simply, the master device (the FEZ) issues a read request, and the slave device (the compass) responds with bytes of data.</p>
					<p>By reading a pair of I&sup2;C registers, and writing some commands, the compass heading can be obtained, in degrees. This is then converted to radians, for convenience</p>
					<p>The purpose of the compass is to keep the robot shooting in the right direction. Upon start up, the robot records the compass heading, which is the direction of the opponent goal. This is then compared with the compass heading to find the field-relative robot orientation</p>
				</section>
				<section>
					<h3>Using the light gate</h3>
					<p>The laser is connected directly to the power supply coming from the FEZ. Originally, it was connected to the 5V supply, but this was deemed "Extremely blinding", so was taken down to 3.3V.</p>
					<p>The photodiode generates electricity when the laser points at it. This generated voltage can be measured by the FEZ, on an analog input. When the beam is unbroken, it hits the photodiode, and a voltage is generated. If the beam is broken (by the ball), the photodiode generates a lower voltage. By comparing the voltage across the photodiode to a known threshold value, it can be determined whether the light gate is obstructed</p>
				</section>
			</section>
		</div>
	</body>
</html>
